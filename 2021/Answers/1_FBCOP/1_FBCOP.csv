"Horodateur","In your role of context-oriented designers, did the proposed development methodology help you to better elicit the contexts and features of your context-oriented application?","Did describing the rationale of the non-trivial contexts and non-trivial features help you to decide whether the contexts and features of your context-oriented system are relevant?","In your role of context-oriented designers, did the proposed development methodology help you to better structure the contexts and features of your context-oriented system? In other words, did it help you to better elaborate and organise your context and feature model?","In your role of context-oriented designers, did the proposed development methodology help you to define the mapping from contexts to features, in other words what contexts trigger the activation or deactivation of what features?","How do you assess the complexity of using this development methodology to design context-oriented systems? (As opposed to not having use such a development methodology)","Can you mention one or more positive aspects of this proposed development methodology? (What did you like? How did it help you?)","Can you mention one or more less interesting aspects of this development methodology?","Do you have any further suggestions regarding how to improve the proposed methodology?","How do you assess the expressiveness of the proposed programming framework to declare the context and feature model?","In a few lines, justify your previous answer by explaining what you liked or not and what aspects can be enhanced.","How do you assess the expressiveness of the proposed programming language in the declaration of the mapping model?","In a few lines, justify your previous answer by explaining what you liked or not and what aspects can be enhanced.","How do you evaluate the overall complexity of implementing feature definitions?","What aspects of defining features did you consider easy? Explain.","What aspects of defining features did you find complex? Explain.","How do you assess the complexity of the imposed files structure of feature-based context-oriented applications? An example of the files structure of a smart messaging system is shown below.","Explain your previous answer. What did you like or not? Do you have some suggestions to improve it?","In hindsight, now that you have implemented a first feature-based context-oriented application, how do you assess the overall complexity of the programming framework?","Explain your previous answer.","Can you mention one or more positive aspects of this proposed programming framework?","Can you mention one or more less interesting aspects of this programming framework?","Do you think the proposed programming framework helps you in tackling the intrinsic complexity of building of feature-based context-oriented applications while avoiding accidental complexity? (Intrinsic complexity refers to the natural complexity of creating feature-based context-oriented applications while accidental complexity is that added by developers in the programming framework to implement such applications.)","Explain your previous answer.","Do you have any further suggestions regarding how to improve the proposed programming framework?","Did you think that the user interace library is sufficiently usable and easy to use? Explain.","Do you think that the API (Application Programming Interface) of the proposed user interface library is sufficiently complete?","If you found that the API is not complete, which functions is(are) missing?","Can you mention one or more positive aspects of this proposed user interface library?","Can you mention one or more less interesting aspects of this user interface library?","Do you have any further suggestions regarding how to improve the proposed user interface library?","Which visualisation tool did you use in your developping and debugging tasks?","Can you explain a situation where you used the Feature Visualiser tool?","Can you explain a situation where you used the Context Feature Model Visualiser tool?","Do you have any further suggestions regarding how to improve the proposed visualisation tools? Or can you think of other visualisation tools that could be helpful?"
"2021/12/18 5:10:26 PM UTC+1","3","2","3","3","4","C'était bien expliqué et ça nous a permis de gagner du temps","La partie du lexique était un peu redondante ","","4","C'était clair et ça permettait d'avoir une vue d'ensemble précise ","2","Les désactivations pas vraiment prises en charge ","4","Visualiser l'ensemble ","Trouver des noms cohérents et différents pour chaque feature ","3","Nous l'avons trouvé cohérent et facile mais le dossier skeleton n'avait pas un nom très intuitif ","2","Pas toujours facile de comprendre comment les fichiers étaient liés les uns avec les autres et devoir respecter certaines typographies de noms pour que ça fonctionne ","Les différents dossiers permettaient de facilement comprendre la structure générale que le code devait avoir ","Devoir mettre certains fichiers dans skeleton qui aurait aussi bien pu se retrouver dans le dossier des features ","3","La structure générale proposée nous a aidé à correctement nous lancer dans le code et donc à ne pas rendre le problème plus complexe dès le début ","","Elle est fort longue et on a parfois eu du mal à s'y retrouver dedans, même pour des choses assez basiques","2","","Elle a l'air assez complète pour faire des choses simples","Difficile de s'y retrouver dedans ","","Context Feature Model Visualiser","","Nous l'avons utilisé pour être sur d'avoir lié nos contexts et features correctement ",""
"2021/12/18 5:30:04 PM UTC+1","3","3","1","1","2",":(","Dont see the point of it","","1","I dont like how it works, COO is clearer and easier","1","I dont like how it works, COO is clearer and easier","2","it's not that hars since its a ""small"" implementation","but it'll probably become very hard when the project grow","2","a LOT of files that should be linked under the same class","1","didnt like how it works","-","context-feature","2","i dont hink it will avoid this kind of complexity","","not realy, some weird behaviour with some functions","2","","-","why not use FX directly ?","","Feature Visualiser;Context Feature Model Visualiser","had a bug whti the context activator","had a bug whti the context activator",""
"2021/12/18 6:05:44 PM UTC+1","3","4","3","3","1","the use of the Ruby programming languages makes the refinement very easy to write and read.
I come from the Rust ecosystem and i'm sure that a similar system would be *ugly* both to set up and to read.","writing graphical user interfaces is really hard. We struggled so much in this.","","4","From my understanding, the use of Ruby and its reflexion system helps a lot.
The fact that ruby evaluates files from the top to the down allows a lot of interesting behaviours that have been exploited in the framework.","4","Ruby allows to define tiny and simple DSLs, which makes it easy to write complex application using a very simple syntax.","2","It was very simple to sit down on a table and discuss with your mate about what would be required for the messaging application. We had to imagine how we want it to be and use our imagination, allowing us to try to experiment new things.","Much of the features we thought about were bad ideas. We had to throw away them either because they just would not fit with the other features or because they would be useless in most real-world usages.","2","It was very painful at first, but after some time we understood why it was required and why it was a good idea to follow this model.","2","It is very easy to read once it's there, but it is way to hard to write. The features interact with each other in a sometimes non-predictable manner, which makes debugging more complex than it should be.","the programming framework uses very well all the different aspects and characteristics of the ruby programming language.","We had a lot of pain understanding the differences between behavior_adaptation and user_interface_adaptation, the naming of the modules defining the adaptation.

Sadly, the framework itself is complex at the beginning. It took us several hours to understand what is actually happening. There's a very steep learning curve.","4","The framework was quite complex to use, but its complexity is still lower than implementing a {feature,context}-oriented application from scratch.","The only thing i miss from the programming environment is... a type system :(
i really think it would help us to catch a bunch of bugs before actually running it.
This is not fixeable sadly, as ruby itself has no type system.","It was usable, but it definitely lacked any kind of proper documentation. We understood that the provided framework provided an abstraction layer over FXRuby, but it hide too much features from it while exposing others.
When we want to do a graphical thing, it is not clear whether if we should dive in FXRuby documentation or in the framework implementation to find what we want.","1","I don't think it lacks functions. I do think it lacks sufficient documentation.","It allowed us to write graphical application.. which is quite unexpected given our level in graphical interface conception.","We don't have much to say given our knowledge gui frameworks.","","Context Feature Model Visualiser","We did not use it. The information it displayed were very insufficient.","We needed to ensure that a couple of features were activated in the correct order.
We also needed to check what feature is activated and when.",""
"2021/12/18 8:18:27 PM UTC+1","3","2","3","3","3","It is interesting to have such development methodology in order to model COP applications. It is a very clear way to do it. ","Very hard to develop using RubyCOP.","","4","Speaking about the expressiveness, we couldn't do better","3","It is very clear but it could lead to a big code very fast.","2","It is very easy to use the model view method in order to develop our feature definitions.","It is hard to know exactly the scope of our global variables. And the ""proceed"" mechanism is hard to understand.","4","The file structure is great and doesn't need any improvements","2","The COP part is very easy to understand and to implement, but the programming part is hard to code.","Clearful to declare a COP.","Doc is missing","3","It is helpful in order to develop feature-based context-oriented applications, but hard in RUBY.","","No, the UI library is not sufficient and hard to use. (Bugs using ""above"", colours that goes to default, ...)","2","Didn't had the time to explore and test them all.","Easy to use since it is short.","Not beautiful at all.","","Neither","","",""
"2021/12/19 10:55:16 AM UTC+1","3","3","4","3","2","La première phase nous permet de bien comprendre le sujet et d’avoir une idée de ce que l’on veut faire","-Juste après avoir réalisé les modèles, c’était difficile de réaliser un diagramme de classe et de savoir quelle feature adaptait quelle clase 

-On a du rajouté des feature à notre modèle lors de la phase d’implémenter parce que on ne se rendait pas compte que toute l’implem devait aller dans les features","","3","Juste un peu de mal à comprendre comment activer un context par défault ","4","Très rapide à réaliser ","3","La reproduction de modèle est facile à réaliser ","Il faut déjà avoir une idée clair du diagramme de classe pour pouvoir savoir quelle classe une feature adapte ","4","C’est bien structuré. Le dossier contenant les feature peut juste devenir assez grand","3","Parfois dur a faire fonctionner surtout quand le modèle n’est pas encore cohérent. On cherche pas mal ce qui ne va pas de le modèle sans que les messages d’erreur aide forcément ","La décomposition en petite classe se fait automatiquement donc pas de grande classe qui regroupe tout","Message d’erreur plus précis. Par exemple erreur à l’activation de context dire le context qui pose problème et pas citez tout les contexts que l’on tente d’activer ","4","Tout à fait d’accord, le fait de gérer automatiquement l’activation et désactivation de feature rend la tâche du développeur beaucoup plus facile","On a eu beaucoup de problème pour savoir et décider l’ordre dans laquelle s’active les feature obligatoire et activer par default","Une fois bien compris, oui elle est facile et rapide à utiliser ","3","-Une fonction pour savoir si un ui objet a déjà été créé 
-Une fonction pour ajouter des objets plus complexe (image)","La facilité et rapidité d’agencer les différents blocs","La fonction pour ajouter un objet est assez longue ","","Neither","","",""
"2021/12/19 5:25:27 PM UTC+1","3","2","2","1","3","The testing part is a good way to set baseline requirements","It is rather complicated to realize how many features and contexts we have whilst building an FBCOP application without sketching an initial feature and context model. Building the lexicon as a first step before sketching anything feels like we're doing 2 steps forward one step back every time we go over our progress.","Increasing the initial workload and content seen during the first part of the course so that more assistance can be provided to students when they are building their FBCOP application. Also provide information about the UI much earlier than 10 days before the deadline.","4","Declaring is very easy and visual. Follows the overall flow of a FeatureIDE model.","4","Declaring is very easy and visual.","3","Quite easy","None","4","The structure is very easy to understand and use. No ideas to improve it.","1","It is very tedious to visualize which features affect which class when MANY features are defined. The context-feature activation order makes it reaaaally hard to make things work as they should 100% of the time when we are trying to build something that is somewhat complex. 
A system with certain contexts activated does not always behave the same depending on its history which is so weird.","Makes FBCOP possible !","The debugging which is often due to the way the programming framework is implemented, meaning that we have to consider much more things when building our models.","2","Well explained in the previous answers","Enhance the documentation in order to provide many more examples of tricky situations. 
It is necessary to know the framework before implementing anything, maybe show the framework to students earlier.","FXRuby in itself is alright, however using the RubyCOP version of FXRuby adds another layer of complexity. Overall OK.","2","","Uses FXRuby which is well documented.","Many tedious arguments in each function for an object oriented language.","","Context Feature Model Visualiser","No","Yes. Model says feature is activated, and generated test suite says the same thing. Framework does the opposite.","Resize window with the models, and allow for moving without just clicking on the text section."
"2021/12/19 5:35:27 PM UTC+1","3","3","3","4","2","More reflection before taking actions.","It takes a lot of time. It was sometimes a little blurry to know if we were on the right track.","Donnez de tips and tricks pour faire moins d'aller-retours pendant le processus de reflection, ce qui fait perdre beaucoup de temps.","3","Beaucoup de répétition dans le code de cette partie-là.","2","On a eu une bataille de contexts pour une feature sans trop d'idée de comment la résoudre.","3","Ruby est un language plutôt simple a prendre en main. On a su reprendre beaucoup d'éléments qui nous étaient fournis.","Avec simplement une erreur annonçant un incompatibilité du modèle, difficile de trouver la cause, malgré les outils fournis.","2","Beaucoup de fichiers assez courts et petits. On aurait préféré des fichiers 2 fois plus longs mais 2 fois moins nombreux. La structure des dossiers était claire.","3","Avec les éléments de base fourni, nous avons rapidement trouvé notre chemin.","Tout le travail automatisé d'activation/désactivation et les vérifications de compatibilité des modèles.","Le nombre de lignes répétées/similaires + le nombre de fichiers nécessaire à la structure du projet.","4","Toute la partie déjà implémentée aidait énormément.","","Non, j'ai trouvé assez complexe de s'en servir pour créer de nouveau éléments.","2","","Il y a beaucoup de lien entre les éléments: on peut ajouter des éléments dans, au dessus, en dessous,... des éléments déjà présents.","Les liens ne sont pas tjrs clair et à cause de 'proceed' et des liens entre les classes, la structure des éléments visuels changeait sans que je ne comprenne vrmt pourquoi.","","Context Feature Model Visualiser","","Pour résoudre les problème de modèle incompatible et pour visualiser la version mise a jour de notre arbre, sans devoir repasser par FeatureIDE.","Nous n'avons pas trouvé de tutoriels d'explication pour le feature visualiser."
"2021/12/19 6:18:30 PM UTC+1","3","2","3","3","3","Implementing features/contexts one a the time was a good idea.","We didn't fully understand the methodology so we aren't sure that we can give less interesting aspects.","","4","The framework is very expressive, we know what we are doing.","4","The mapping is very straighfoward","2","Declaring features and constructing the model is very easy.","Veryfing our model and finding erros in it was challenging. Expecially errors such as : model not consistent after : ... were hard to correct in our experience.","3","It's easy to use but it's not always very clean. For instance the feature_definitions folder is very big. Maybe classes inside this folder can be split into subfolder.","2","Compared to OOP, COP is harder to implement. Overall the framework does a good job but it's a bit heavy to use.","It helps to facilited the developpement when you have a lot of different behaviors in your application. ","Its very heavy. For instance when declaring a new feature, one needs to change multiple files(feature, mapping, maybe context, and the new class itself). Another drawback is that we feel in practice most features from an app don't change based on contexts. So having a heavy framework for those few cases isn't pleasant to use.","3","It does the job overall but as said previously the machinery is heavy.","","It works but it's not easy to use","3","We didn't manage to implement popups.","The naming of methods is self-explainatory","The arguments of the methods are numerous and not always in the same order. It's not always practical","We experienced segfaults (core dumped) during our testing. We don't know if it was a mistake on our side or not. A segfault in a high-level language seems weird to have.","Neither","","","Maybe you can simplify the activation of the tool. The usage is good but lanching the tool is slow and sometimes it didn't work for us."
"2021/12/29 1:46:45 AM UTC+1","3","3","3","4","3","I liked the proceed mechanism. It's a neat way to enable modifications of the UX based on context.","Knowing how one should approach the development of his app isn't always clear.
It took some time to get used to the methodology and it wasn't really easy and possible to structure the code as we structured the models","","3","I believe that because of the ruby framework we get hit by some limitations.
But it may also just be because of our limited time and knowledge on the subject.
Maybe a webdev approach (using html, js, css / react) would be a good idea too? ","3","I personaly don't like Ruby a lot.
Maybe making a node module / using nodejs and html/css/js etc would be a good idea too.","2","Making the contexts, features & mapping","Implementing everything in Ruby wasn't easy (lack of time too) since it's the first time we've used the programming language. ","3","Knowing how many files there were, I don't know if I could've structured them better than that.","2","It's Ruby and It's the first time we've used it, so we couldn't work as fast as we initially hoped we would.","-","-","2","I don't know if it helps tackling the complexity of building such an application, but it being in a language we didn't get used to before-hand definitely didn't help.
But some mechanism implemented in the framework were definitely helping a lot (proceed mechanism). ","","Somewhat","2","","I don't really have something to menssion","Maybe if it could be a little more complete (/ with more use cases) it would help a lot more.","","Neither","","",""
"2021/12/29 11:34:34 PM UTC+1","3","1","4","3","2","i liked to see the progress in my comprehension and my work","In the report the class diagram part","","3","i didnt like to code on ruby.","4","nothing to say","4","nothing to say","at the begining it was a bit complex but it was more easy when i understood how to add some features","2","no","2","the framework was ok for basic changes but hard to understand and bind with the ui","the mapping is easy ","no","3","i think that the framework can reduce the complexity of designing context oriented app","","no it was very hard to bind the ui","2","","no","i didnt had the time to work on it","","Context Feature Model Visualiser","","",""
"2021/12/31 1:12:15 AM UTC+1","3","3","4","3","4","I learned to differentiate the implementation of features and contexts from a developer/client side rather than a user side. For example, the feature is implemented but only used when activated by a user's context; rather than implemented only when the user context requires it.","Knowing the contexts in which the users are going to use the application allows the developer to make better decisions during the analysis steps.

There wasn't a clear link between what we learned in theory sessions and what we did in practical sessions until the last few weeks.","Maybe make it clear that the feature and context model are to be seen from an implementation point of view rather than a user workflow point of view. ","3","In the syntactic sense, the way we declared contexts and features were similar; so it made better sense.

A lot of modifications had to be made to our feature and context models to fit with declaration rules. Mainly the feature model.","4","It was a one-to-one mapping with our model.","1","When a feature is concrete and has clear methods and attributes.

Otherwise, when attributes or methods were defined in a subclass, it wasn't very instinctive. For example, our super class ""Account"" would get its status in a subclass ""Offline"", ""online"" or ""DoNotDisturb"".","Abstract features were difficult to pin down.
Adapting the view was a bit tricky because in some features we had to use variables defined in another unrelated class.","4","The organization make it easy to know what the files correspond to, and infer what they accomplish. ","1","It wasn't easy to understand where the proceed methods lead in some aspects. For example, when sub features were mandatory, proceed seem to lead to the next feature that is at the same depth in the tree. While when the feature is optional or alternative, proceed seems to lead to the parent feature.
It wasn't easy to understand which features had access to which attributes and/or methods.","The visualization tools are very helpful to check the behaviors when changing contexts.

Seeing that this framework is trying to emulate what OOP did (eliminating 'if' conditions to check for a 'type' change) and is trying to eliminate conditions checking every time we change contexts, it opened my mind to the possibilities of the language for IOT applications.","Ruby was used, and the unfamiliarity with the language hindered the process of understanding the Context-Oriented programming.","4","If we had to start from scratch, it would be very complex to connect all the modules together.","","Honestly speaking, we had a problem understanding the interface library and the parameters to use. Understanding how the different classes used the 'proceed' method to access a method defined in another class. Indeed, we didn't know at the time if a feature would access his super class or his neighbor class when proceeding.","3","","The documentation (slides) were clear.
'Set_epilogue' and 'set_prologue' were very useful.","We can't think of any.","","Feature Visualiser;Context Feature Model Visualiser","To detect if the contexts that were supposed to be activated were indeed activated.
To detect if the features and contexts that were supposed to be connected were indeed connected.
It provided a clear view of which classes were currently active.","It allowed us to check if the feature and context model tree our program used were the same as the tree we designed.
It made it easier to visualize where the 'proceed' methods were going.
Same as the Feature Visualizer, to detect if the features and contexts that were supposed to be connected were indeed connected.",""
"2021/12/31 1:20:05 AM UTC+1","2","3","2","2","1","Theoretically this methodology seems cool and quite promising. I did like the fact that we could think about which context toggles which features from the pov of a designer rather than a developer and a template for the general methodology.","The methodology emphasizes too much the design part and not enough the development part (not to mention the testing part). Therefore, it is almost mandatory to use the frameworks provided by the course in order to implement and follow the methodology. However, I guess this is also because the methodology is quite new and not widespread enough.","","2","I have to admit that I'm used to reading lots of documentations online and I rarely have to read the documentation as many times as I had to do for this framework. Usually, concepts as ""prologue, epilogue"" are named ""on_destruct, on_join, etc"", and this change of names followed some other concepts too. Having some different names here and there doesn't impact that much the expressivity but in combination with a language such as ruby, a custom framework, a ""magical way"" to handle dependencies in ruby, made it quite difficult to understand what everything had to in the framework. Therefore, I didn't find it very expressive.","4","This part was actually quite expressive because it's just a Dictionary, and this is exactly how it would have been done in most languages ","1","Unfortunately I didn't find it easy","The fact that features can't just ""simply exist"" because they need to be mapped to a context makes it hard to debug the program when you add a new feature because you have to carefully add them one by one in order to know what feature crashes the program (since the debugger only tells you that ""mapping is not valid""). I'd like to add the fact that everything relies on the concept of ""modules"" is very impractical and requires us to spend a lot of time in drawing some diagrams in order to know the modules in each feature and prevent bugs.","2","I think the concept of skeleton classes is cool but makes it hard to understand what skeleton class is related to a specific feature without the diagrams. Therefore, I'd suggest to organize the skeleton classes as follows : 
- put all models together
- all controllers together
- all views together
etc. (i'm assuming a MVC architecture). ","1","Ruby is not specifically hard but for very small projects, it can be simple. However, this framework is inherently complex and makes ruby seem more difficult than it is. Furthermore,  I think that one has to already know some ruby (and by that, I mean more than the couple hours that we had during the tps), therefore I had to run some smaller projects on the side to understand better how ruby works and have better understand of the framework itself.","/","The UI library has a lot of documentation but it is definitely not built for real applications. It looks a lot like a lower-level UI library (SFML, SDL, QT, etc.) but in a high-level language. + the bugs... :(","1","I think that this framework inherently adds a lot of accidental complexity and therefore doesn't really help in tackling the intrinsic complexity. Indeed, I have some ideas on how to implement a FBCO application with other frameworks that are not specifically designed for this purpose. Nevertheless, I trully believe if one has to develop such an application, they should avoid using your framework. I don't mean any harm, I'm rather speaking in terms of time investment. If the framework was in another language (such as typescript for example), I believe it would be a lot better because ruby inherently has very poor syntax help from IDEs. I would gladly discuss this with you face to face and bring some ideas for next years if you'd want me to.","","No, there are many bugs and everything has to be coded. It's basically the same as ","4","","I think this library could achieve basically anything and the documentation is not so bad. However, it would require so much time to develop a real application because it is basically a giant lego box with hundreds of different pieces. But the manual is in swedish and you only speak korean. (it's a joke but that's basically how it felt :( )","As mentioned above, hopefully the library can achieve almost anything.","Use something web-based, it would be cool and people would rather focus on understanding the theoretical aspects of the framework rather than understanding how the UI works (which is not the goal of this course)","Neither","","","The visualisation tools are quite cool in order to know if all the features are actually there. And I think they could be useful for sure! If you want more informations, I'm SME14b :)"
"2021/12/31 2:58:08 AM UTC+1","3","1","3","2","2","The assistants are there to explain better how what we have to use works, but lab session's time is limited","Getting to know and understand the tools takes a lot of time, which led us to have to rush at the end of the semester, and not being able to finish what we intended to implement. There could also be more examples in the lectures, including more complex ones to give us a better understanding of what was expected of us.","Designing the rationale did not improve our understanding, and as the lexicon, took quite some time which could have been used for more interesting things.
RubyCOP documentation should be more code-oriented so we'd have known where to put which files, as well as know exactly what kind of code was expected in which file. It also could have included more info about the structure of the framework itself, or the MVC. 
Given our the time we needed to correct quite a few times our models, as well as our knowledge of the framework and Ruby itself, we thought that the time given to implement the application as well as the UI were underestimated.
The way the tasks were given was also frustrating, asking us to imagine an application to build the model, and then asking us to simplify a lot so that we can really implement it. We could have been told this ""detail"" at the beginning which would have spared us a lot of wasted time.
Another time-consuming ""detail"" that we had to fight against was the conceptualization of NOT's which were not implemented in the framework and made us change again our models.","2","Instead of copy-pasting our feature model into ruby code in the framework, the process could be automated","3","The mapping is written in an programmer-friendly way","2","Activating a child feature activates its parents","Some feature refine more than one parent feature, choosing the right ones is not easy. 
Defining if a feature is abstract or not wasn't really explained.","1","The name of the Ruby files should be more explicit (e.g. smart_messenger versus messenger_service)
The single controller for all the MVC's of the app should have been clearly mentioned.
The use of quasi-empty files in the skeleton part is confusing.","2","As the model and the framework work in symbiosis, the programmer has to have at least a basic understanding of both before working on one or the other and understand the limitations of both","Some modelling errors are well found by the framework and pointed out to the programmer","Lots of copy-pasting between the models on Feature IDE, the mapping (on random softwares), the .txt files needed to generate the test suites and the Ruby code we had to implement","3","As there are several improvements to set in the methodology, the complexity was not that reduced.","Creating a tool to tackle the copy-paste issue would spare us time and bugs.
The number of files increasing highly with the development is an issue. Base-classes in the skeleton could have been generated automatically by framework.","The concept of the API is easy to understand, but the way we are supposed to code it is a lot more tricky.","3","","Documentation is easily available","Getting started with it may be overwhelming","","Context Feature Model Visualiser","","",""
"2021/12/31 3:57:36 PM UTC+1","2","1","3","2","3","It gives a structure for the development. We had a basic idea of the structure of the application that can be used for the steps after. ","Every elements of the models are linked but when you want to change an element, you have to change manually all the elements in all models (created on different software)
In other words, everything is linked but nothing is linked in the model creation.","The mapping model should be created in more user efficient way (automated, half automated). The feature model and context model are linked together, having them in the same file would be easier for the analyst to create them","3","As soon as your model gets a lot of features, it's easy to get lost in the code","4","Very expressive and easy to declare","2","Creating the model was easy once all the feature were created","The declaration of the feature is complex and has too much info that aren't too much relevant. We also had issue that forced us to put ""_"" in some places even though it wasn't required at other places.","2","We don't believe that the ""smart_messenger.rb"" file should be located in the skeleton. It should be at the same place as the main files.
When there is a lot of features, it is too easy to get lost. The model is a tree so why not using a folder hierarchy structure in the feature definition.
The skeleton folder holds ""model"" but also ""view"", those should be in separated folders (can be in the skeleton folder). Besides, those files aren't useful at all. They hold little to no information because the whole code is in the feature file. They are just another source of bug","1","Everything is handled by developer. For example the Laravel framework use a command line system to create all the needed files at the right place with the right names, ... This decrease the amount of work and bug source.
Error message are just not useful. The error trace usually pointing to places in the framework code. Not helpful to debug the code","The basic structure given by default is very useful for the developer","The fact that the framework asks for at least one default context. The context are already boolean values. This forced us to split the context into 2 sub context to have a ""true"" and a ""false"" like we imagined (e.g. Open context needs to be split into ""is_open"" and ""is_closed"")","2","Yes it helps tackling the intrinsic complexity but it creates a lot of accidental complexity by letting everything in the hand of the developer (every names must match at all time for example)","Having an automatic way to create the features, context and over all the mapping model would be interesting. Other elements are given in the previous answers","The library was really hard to use. Especially when we wanted to handle activation and deactivation of contexts (and therefor features) with the set_prologue and set_epilogue","4","","The API is complete","The utilization is too complex and require a lot of investment.
Furthermore, the documentation given wasn't enough, important elements for basic application were there but it needs more structure and more clear explanation for more complex application ","","Context Feature Model Visualiser","","We used it to check if the overall model was correct while debugging","Opening the tools wasn't really easy (we used VSCode). Why no running them on a server that can be reached through localhost"
"2022/01/05 6:47:06 PM UTC+1","4","4","3","4","4","- It is composed of few steps and easy to understand
- Visually simple to understand","- We like featureIDE, it was easy to use","","3","- To create context-features and mapping them it was ok. 
But we had trouble for implementing the UI. ","4","It was very intuitive, the data structure is very explicit.","4","The 2 array for the mandatory and optional was easy to understand and use.","- The fact that some features were abstract and may make it more complicated when programming","3","We didn't like the skeleton folder. It regrouped too many classes. View, Models,.... After implementing our real app it was very messy.","3","Same as before, the UI was very complicated to use and we didn't really understand how all classes interacted between them.","Esy to create contexts, features as well as the mapping.","It was a bit cumbersome that we had to launch 3 terminals just to enable/disable contexts.","4","For very complex applications, it would be more easier with this framework.

But for everyday things/apps, it may be overkill.","","No. There is no documentation and examples on how to use it in a simple way.

We lost all our time trying to understand how it worked.","3","","- We liked the fact that when we added a new layout component, it went above previous items. Just like a stack","- the debugger didn't provide us enough informations.
- there may be too many arguments for the function.","- More documentation
- More examples
- Make it more simple to use","Neither","","",""
"2022/01/06 12:11:32 PM UTC+1","4","2","4","3","3","Une méthodologie assez claire pour les débutants qui ne savent pas forcément ce qu'est les Feature-Based Context-Oriented Programming","Pour un neophyte, design un système à priori n'est pas dur grâce à la méthodologie.
Cependant son design ne concordera pas toujours à la réalité lors de l'implémentation. 

Par exemple, nous avons au départ design un système, il se trouve que l'implémentation ne collait pas toujours forcément a notre diagramme car pas possible ou plus difficile que prévu. 

Nous avons donc, lors de l'implémentation, adapté certains aspects de notre diagramme. 

Donc en gros nous avons codé en fonction du diagramme mais nous avons également design le diagramme en fonction de  l'implémentation. ","Ca parait peut être moins logique mais il nous paraissait plus facile de design le diagramme en réflechissant aux features et contexte ""sur le tas"". Pour ensuite en faire le lexicon. 
(et pas d'abord le lexicon puis le diagramme)
","3","Les contexts et le mapping sont facile a déclarer et c'est plutôt chouette.
Les erreurs ne sont pas assez explicite: il serait intérressant lorsqu'une feature ne peut pas être activée, dire laquelle plutot qu'une liste de tout ce qui a essayé d'etre activé.","2","N'ayant jamais fait de ruby, mon avis sera sûrement biaisé.
Certaines fonctionnalité semblait ""magique"", les variables précédé d'un @ qui se retrouvaient dans plusieurs fichiers et déclarée dans un autre par exemple. Il faut utiliser la recherche de l'IDE pour en trouver sa déclaration.

Ou sont les imports dans ce langage ? Je me suis retrouvé plusieurs fois a chercher le fichier déclarant un objet par exemple car aucun import n'était définis. Par exemple dans main.rb, j'ai pris du temps à comprendre d'ou venait SmartMessenger.run() ","3","Il est facile de créer l'arbre des features dans le feature_model_declaration.","Comprendre les can_adapt et les proceed mais qui une fois appris sont très utile.","4","On trouve facilement ce qu'on veut car les fichiers sont bien structurés.
","3","Un nouveau paradigme pour nous donc ce fut difficile. Selon moi, il y a une grosse learning curve.","Une fois pris en main, il est facile de s'y retrouver et de créer une nouvelle feature/context.","Implémenter une fonctionnalité prend beaucoup de temps et de réflexion comparé à un autre langage/paradigme.","3","-","","Du tout. La documentation de cette librairie est quasi-inexistante. 
L'implémentation d'une bête fonctionnalité avec cette librairie nous a causé soit des crash, soit des résultats insatisfaisant. La librairie rajoute énormément de complexité au framework.","2","La documentation","/","/","Écrire une documentation ou changer de FXRuby vers quelque chose de mieux. ","Context Feature Model Visualiser","","Pour représenter l'arbre implémenté et vérifier que cet arbre correspond à notre diagramme. Également pour vérifier que les contextes activent les bonnes features","Un script permettant de lancer le serveur et les outils désirés en même temps"
"2022/01/09 1:49:09 PM UTC+1","4","4","4","4","3","Logic of the step by step methodology (model design into mappin into generates test into implementation etc ...)","waterfall methodology -> lot of work to update the design of contexts/features","","4","The presentation and the documentation is good","4","The presentation and the documentation is good","4","Easy and short syntax","Nothing","4","Very logic and intuitiv","2","Lot of time to unterstand how the framework works","Code well structured","Many files, class, method ... difficult to understand the whole framework","3","We can see very well the challenges of feature-based context-oriented programmation","","No, diffult to see how to use it","3","","With code example we can see how it works","Difficult to unterstand how to use it","","Feature Visualiser;Context Feature Model Visualiser","","",""
"2022/01/10 1:01:03 PM UTC+1","3","2","2","3","2","- Allowed us to be sure to have all the requirements done
- We liked that the model is incremental
- Allowed us to do the testing and then change retrospectively our model","- Complex to use at first
- Not user friendly
- Lexicon takes a lot of time to write","","3","We managed to code everything we put in our design so the framework is working as expected","3","We just had to use our graph and put them in ruby code and it worked easily ","2","We just followed the syntax of the documentation","Error messages weren't precise enough sometimes to understand what the error was","3","Didn't like the fact that there are a LOT of ruby files in the features
We liked that it was easy to add new features, just create a new rb file in the feature_definitions folder","2","The adaptation of the UI was not easy at all","- Effective at making feature-context programing
- Mechanism proceed works really well","- The UI is not great
- Class variables are confusing to use when in multiple different files (ruby limitation)","3","We think that the framework is really useful at making context-oriented applications, and with the documentation, it's easy to use","","Not easy to use as there isn't much documentation","4","","When understood, it's easier to implement the UI","Hard to use and understand, not easy to setup","","Neither","","",""